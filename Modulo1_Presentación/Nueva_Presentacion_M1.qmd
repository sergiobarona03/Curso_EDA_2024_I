---
title: "Módulo 1: Básicos de R"
format:
  revealjs
editor: visual
fontsize: 13pt
---

## R y RStudio

Quarto enables you to weave together content and executable code into a finished presentation. To learn more about Quarto presentations see <https://quarto.org/docs/presentations/>.

## Consola

When you click the **Render** button a document will be generated that includes:

-   Content authored with markdown
-   Output from executable code

# Estructuras de datos

Durante las próximas sesiones, nos concentraremos en cuatro estructuras de datos: **vectores**, **matrices**, **data frames** y **listas**. Un arreglo de datos \[**array**\] es una matriz con varias capas, pero nosotros abordaremos principalmente las siguientes estructuras

![Estructuras de datos](NuevaImg1.png){width="500px"}

# Clases de objetos

La función `class()` permite recuperar la clase de un objeto. A continuación, consideraremos las siguientes clases:

![Clases de objetos](NuevaImg2.png){width="500px"}

# Estructuras de datos y clases de objeto

Tanto las **matrices** como los **data frames** representan estructuras rectangulares de datos (datos en filas y columnas). Sin embargo, los **data frames** pueden contender distintos tipos de datos en una misma estructura.

![Clases de objetos](NuevaImg3.png){width="500px"}

## Crear objetos


::: columns
::: {.column width="50%"}
### Vectores


Por convención, el operador de asignación `<-` se usa para asignar un valor a una variable. Defínase dos vectores:

```{r, echo=TRUE}
text <- c("x", "y", "z") #Character
text
```


```{r, echo=TRUE}
n = 1:10 #Numeric
n
```


```{r, echo=TRUE}
z = 1L:6L #Integer
z
```


Para seleccionar el *i* elemento del vector, se usan corchetes `[i]`:
```{r, echo=TRUE}
z[5]
```

Para verificar la longitud del vector, se usa `length()`:
```{r, echo=TRUE}
length(z)
```

Los nombres de los elementos pueden ser asignados con `names()`

```{r, echo=TRUE}
names(z) = c("uno", "dos", "tres", "cuatro", "cinco", "seis")
z
```
:::

::: {.column width="50%"}

Para el caso de los **vectores**, R emplea la **ejecución por elementos**. Así

```{r, eval = TRUE, echo=TRUE}
a = 1:6
a*a
```


![$~$](Img1.png){width="230px"}


```{r, eval = TRUE, echo=TRUE}
b = c(1,2)
a*b
```

![$~$](Img2.png){width="230px"}
:::
:::





## Crear objetos (cont.)


::: columns
::: {.column width="50%"}
### Matrices

Una matriz es definida usando la función `matrix()`. El parámetro `byrow` determina si las entradas son completadas según filas (`TRUE`) o columnas (`FALSE`). Así:

::: columns
::: {.column width="48%"}
```{r, echo=TRUE}
m1 <- matrix(1:9, nrow = 3, ncol = 3, byrow = T)
m1
```
:::

::: {.column width="48%"}
```{r, echo=TRUE}
m2 <- matrix(1:9, nrow = 3, ncol = 3, byrow = F)
m2
```
:::
:::

Las entradas de la matriz son seleccionadas según filas [**i**, j] y columnas  [i, **j**] 

```{r, echo=TRUE}
m2[2,1]
```

```{r, echo=TRUE}
m2[2,]
```

```{r, echo=TRUE}
m2[,1]
```


![$~$](NuevaImg4.png){width="350px"}

:::

::: {.column width="50%"}

$~$ $~$

$~$ $~$

A diferencia de la multiplicación por elementos (`a*b`), el producto de matrices se obtiene de

```{r, echo=TRUE}
m1 %*% m2
```

Otras operaciones útiles:

![$~$](NuevaTabla1.png){width="450px"}




:::
:::



## Crear objetos (cont.)
::: columns
::: {.column width="50%"}
### Listas

Las listas son estructuras heterogéneas de datos. Aunque son estructuras unidimensionales, las listas permiten almacenar objetos de clases distintas (e.g.: vectores, matrices, data frames u otras listas). Así:


```{r, echo=TRUE}
v1 = c(1, 2, 3, 4)
v2 = c("a", "b", "c", "d", "e")
m1 = matrix(v1, 
            nrow = 2, ncol = 2, byrow = T)

lista <- list(vector1 = v1, vector2 = v2, matriz1 = m1)
lista
```


En el caso de las listas, los índices funcionan así:

```{r, echo=TRUE}
lista$vector2
```

```{r, echo=TRUE}
lista[[2]]
```

```{r, echo=TRUE}
lista[[2]][1]
```


:::

::: {.column width="50%"}

$~$ $~$

$~$ $~$

La siguiente figura muestra la selección de los elementos de una lista


![$~$](Img3.png){width="500px"}
:::
:::

## Crear objetos (cont.)

### Data frames

Los **data frames** son estructuras rectangulares de datos que pueden contener objetos de diferente clase (e.g.: texto, numéricos, lógicos, etc.). Creamos un **data frame** con tres columnas (id, sexo y edad)

```{r, echo=TRUE}
id = 1:4
sexo = factor(c("male", "male", "female", "female"))
edad = c(15, 26, 43, 56)

df = data.frame(id, sexo, edad)
df
```

::: columns
::: {.column width="50%"}

Al igual que las matrices, los índices en los **data frames** funcionan así:

```{r, echo=TRUE}
df[1,2]
```

```{r, echo=TRUE}
df[1,c(1,2)]
```

```{r, echo=TRUE}
df[1,]
```

```{r, echo=TRUE}
df[,1]
```

```{r, echo=TRUE}
df[-c(1,2),] # Omitir primera y segunda fila
```

```{r, echo=TRUE}
df[,-c(1)] # Omitir primera columna
```

:::

::: {.column width="50%"}

El mismo resultado es obtenido a partir de los **nombres** de las **columnas**. Para verificar los nombres, se usa la función `colnames()`.

```{r, echo=TRUE}
df$edad
```

```{r, echo=TRUE}
df$edad[1]
```



```{r, echo=TRUE}
df[c("sexo", "edad")]
```




:::
:::




## Condicionales



::: columns
::: {.column width="50%"}

A partir de los condicionales, una operación es ejecutada si la condición se cumple (`TRUE`); de otro modo (`else`), establece la operación que es ejecutada si la condición no se cumple (`FALSE`). La estructura es esta:

```{r, eval=FALSE, echo=TRUE}
if (condition) {
  # Ejecutado cuando la condición es verdadera
} else {
  # Ejecutado cuando la condición es falsa
}
```

Considérese este ejemplo para añadir elementos en una secuencia:

```{r, eval=TRUE, echo=TRUE}
vec1 = c(1,2,3,4,5)
n = 5.2

if (n > 5) {
  vec1 = c(vec1, n)
} else {
  vec1 = vec1
}

vec1
```

Cuando la condición no se cumple:

```{r, eval=TRUE, echo=TRUE}
n = 4.25

if (n > 5) {
  vec1 = c(vec1, n)
} else {
    vec1 = vec1
    }

vec1
```
:::

::: {.column width="50%"}
$~$ $~$

$~$ $~$

```{r, eval=TRUE, echo=FALSE}
library(kableExtra)
library(dplyr)
boolean = data.frame(Operador = c("x > y", "x >= y",
                                  "x == y", "!x", "x != y", "x|y", "x & y", "x %in% y"),
                     Descripción = c("Greater than",
                                     "Greater than or equal to",
                                     "Exactly equal to", "Not",
                                     "Not equal to", 
                                     "OR", "AND", "In the set"))
Form.Basic = c("striped", "bordered", "hover",
               "condensed", "responsive")
kableExtra::kable(boolean,
                  caption = "Operadores lógicos") %>% kable_styling(bootstrap_options = Form.Basic, font_size = 20) %>% add_header_above()
```

:::
:::


## Funciones

::: columns
::: {.column width="50%"}
La estructura general de una función en R es la siguiente:

```{r, eval = FALSE, echo=TRUE}
 function(arg_1 = x1, arg_2 = x2, ..., arg_n = xn)
```

Considérese la función `seq()` que define secuencias regulares. A partir de los argumentos de la función, se define el inicio de la secuencia (`from`), el final (`to`) y el incremento (`by`). Por ejemplo:

```{r, eval = TRUE, echo=TRUE}
 seq(from = 1, to = 25, by = 1)
```

Si el parámetro `by` se deja libre, la secuencia puede definirse a partir de su longitud (`length.out`). Así:

```{r, eval = TRUE, echo=TRUE}
 seq(from = 0, to = 1, length.out = 11)
```

Para cualquier funciónn, `?` y `help()` permite examinar su documentación:

```{r, eval = FALSE, echo=TRUE}
 ?seq
```

:::

::: {.column width="50%"}

A partir de `function()`, se pueden definir funciones a partir de la siguiente  estructura:

```{r, eval=FALSE, echo=TRUE}
my_function = function(args){
  #statement
  #statement
  return(y)
}
```

Defínase una función para añadir elementos a un vector ordenado:

```{r, eval=TRUE, echo=TRUE}
vec1 = 1:5
my_function = function(n){
   if (n > 5) {
     vec1 = c(vec1, n)
   } else {vec1 = vec1}
  return(vec1)
}

```

Para $n = 10$ y $n = 2$, 

```{r, eval=TRUE, echo=TRUE}
my_function(10)
```

```{r, eval=TRUE, echo=TRUE}
my_function(2)
```

:::
:::

## Librerías


::: columns
::: {.column width="50%"}
Las funcionalidades de R son ampliadas mediante el uso de librerías (funciones, datos y código compilado con una estructura específica). La librería `ggplot2`, por ejemplo, es  un paquete de visualización de datos en R.

```{r, echo=TRUE, eval = TRUE, error=TRUE}
ggplot
```

```{r, eval = FALSE, echo = TRUE}
install.packages("ggplot2")
```

```{r, eval = TRUE, echo = TRUE}
library(ggplot2)
```

```{r, eval = TRUE, echo = TRUE}
ggplot(data=diamonds, aes(x=price, group=cut, fill=cut)) +
    geom_density(adjust=1.5, alpha=.4) 
```

:::

::: {.column width="50%"}

### Instalar librerías

En este curso, usaremos los siguientes librerías:

```{r, eval = FALSE, echo = TRUE}
install.packages("psych")
install.packages("tidyverse")
install.packages("rafalib")
install.packages("tidyverse")
```

$~$ $~$

$~$ $~$

### ¡ANOTACIÓN IMPORTANTE!

Hay casos en que dos librerías comparte una función con el mismo nombre. Usando `library1::function1` nos podemos referir a la función `function1`que pertenece al paquete `library1`. Un ejemplo:

```{r, eval = FALSE, echo = TRUE}
df = data.frame( id = 33,
  x = c(rep("a", 10), rep("b", 23)))
```

```{r, eval = FALSE, echo = TRUE, error=TRUE}
count(df)
```

```{r, eval = FALSE, echo = TRUE}
dplyr::count(df, x)
```

:::
:::




## Tidyverse


