---
title: 'Introducción al Análisis Exploratorio de Datos (EDA) en R'
subtitle: 'Módulo 2'
fontsize: 8 pt
output:
  beamer_presentation:
    theme: "Berlin"
    fonttheme: "structurebold"
    slide_level: 2
    toc: true
date: "2024-03-16"
header-includes:
- \usepackage{booktabs}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
def.chunk.hook  <- knitr::knit_hooks$get("chunk")
knitr::knit_hooks$set(chunk = function(x, options) {
  x <- def.chunk.hook(x, options)
  paste0("\n \\", "tiny","\n\n", x, "\n\n \\normalsize")
})



```

```{r , echo=F, warning=F, message=F}
library(tibble)
library (kableExtra)
library(plyr)
library(tidyverse)
library(reshape2)
```

# Continuación de EDA univariante: supuestos

## Distribución normal univariada

::: columns
::: {.column width="50%"}

Una variable aleatoria continua $X$ está normalmente distribuida si su **función de densidad** sigue la forma:

$$
f(x) = \frac{1}{\sigma  \sqrt{2\pi}}exp\left\{\frac{-1}{2\sigma^{2}}(x - \mu)^{2}\right\}
$$
donde

$$
f(x) \geq 0
$$
$$
\int_{-\infty}^{\infty} f(x)dx = 1
$$

$$
\int_{a}^{b} f(x)dx = P(a \leq x \leq b)
$$

**Parámetros de la distribución:** media($\mu$) y varianza ($\sigma^{2}$) de la distribución.

:::
  
::: {.column width="50%"}

\bigskip

\bigskip

![Áreas bajo la curva normal](Figuras/theo_normal.png)

:::
:::


## Normalidad univariada 

El gráfico **cuantil-cuantil** (gráfico Q-Q) compara dos distribuciones de probabilidad usando sus cuantiles. Usando la librería `car`, comparamos la distribución de probabilidad de una muestra aleatoria con la distribución normal. 

```{r, echo=F, eval = T, message=F, warning=F, prompt=FALSE, results = FALSE}

dataset <- readxl::read_excel("geih_dataset.xlsx")

library(car)
par(mfrow = c(2,3))
qqPlot(dataset$ingreso/1000, main = "Ingreso laboral (miles $)", ylab  = " ")
qqPlot(dataset$edad, main = "Edad (años)", ylab = " ")
qqPlot(dataset$horas_semana, main = "Horas trabajadas (semana)", ylab = " ")
qqPlot(dataset$t_actual, main = "Tiempo en el trabajo actual", ylab = " ")
qqPlot(dataset$t_viaje, main = "Tiempo de desplazamiento", ylab = " ")
```


## Normalidad univariada (cont.)


La intuición del método gráfico es verificada mediante pruebas formales. Usando la librería `nortest`:


```{r, eval = T, echo=F}
# Analizar la normalidad de las variables continuas
library(nortest) # Anderson-Darling, Kolmogorov-Smirnov (Lilliefors)



############################## Paréntesis: esto es únicamente para la presentación ######################################
nortest_function <- function(x, y){
  if (is.function(y)) {
    w <- x[!is.na(x)]
    return(y(w)$p.value)
  } else {return("Y no es una función")}
}


ad <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, ad.test))) %>% t() 

li <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, lillie.test))) %>% t()  

pearson <- dataset %>% dplyr::select(ingreso,
                                         edad, horas_semana,
                                         t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, pearson.test))) %>% t() 



df_summary <- data.frame(variable = rownames(ad),
                         ad_test = round(ad, 6),
                         li_test = round(li,6),
                         pearson_test = round(pearson, 6))

```


```{r, eval = T, echo=F}
kable(df_summary, col.names = c("variable",
                                "Anderson-Darling",
                                "Lilliefors (Kolmogorov-Smirnov)",
                                "Pearson chi-square"), row.names = F,
      format = "latex", booktabs = T)
```

Se examinan  las siguientes transformaciones


::: columns
::: {.column width="30%"}


```{r, echo = F}
nortest_function <- function(x, y){
  if (is.function(y)) {
    w <- x[!is.na(x)]
    w <- w[w > 0]
    return(y(log(w))$p.value)
  } else {return("Y no es una función")}
}


ad <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, ad.test))) %>% t() 

li <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, lillie.test))) %>% t()  

pearson <- dataset %>% dplyr::select(ingreso,
                                         edad, horas_semana,
                                         t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, pearson.test))) %>% t() 



df_summary <- data.frame(variable = rownames(ad),
                         ad_test = round(ad, 6),
                         li_test = round(li,6),
                         pearson_test = round(pearson, 6))
```

```{r, eval = T, echo=F}
kable(df_summary, col.names = c("log(x)",
                                "A-D",
                                "K-S)",
                                "P"), row.names = F,
      format = "latex", booktabs = T)
```

:::
  
::: {.column width="30%"}

```{r, echo = F}
nortest_function <- function(x, y){
  if (is.function(y)) {
    w <- x[!is.na(x)]
    w <- w[w > 0]
    return(y(sqrt(w))$p.value)
  } else {return("Y no es una función")}
}


ad <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, ad.test))) %>% t() 

li <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, lillie.test))) %>% t()  

pearson <- dataset %>% dplyr::select(ingreso,
                                         edad, horas_semana,
                                         t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, pearson.test))) %>% t() 



df_summary <- data.frame(variable = rownames(ad),
                         ad_test = round(ad, 6),
                         li_test = round(li,6),
                         pearson_test = round(pearson, 6))
```

```{r, eval = T, echo=F}
kable(df_summary, col.names = c("sqrt(x)",
                                "A-D",
                                "K-S)",
                                "P"), row.names = F,
      format = "latex", booktabs = T)
```



:::

::: {.column width="30%"}

```{r, echo = F}
nortest_function <- function(x, y){
  if (is.function(y)) {
    w <- x[!is.na(x)]
    w <- w[w > 0]
    return(y((w^(1/3)))$p.value)
  } else {return("Y no es una función")}
}


ad <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, ad.test))) %>% t() 

li <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, lillie.test))) %>% t()  

pearson <- dataset %>% dplyr::select(ingreso,
                                         edad, horas_semana,
                                         t_actual, t_viaje) %>% 
  summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   ~ nortest_function(.x, pearson.test))) %>% t() 



df_summary <- data.frame(variable = rownames(ad),
                         ad_test = round(ad, 6),
                         li_test = round(li,6),
                         pearson_test = round(pearson, 6))
```

```{r, eval = T, echo=F}
kable(df_summary, col.names = c("cuberoot(x)",
                                "A-D",
                                "K-S)",
                                "P"), row.names = F,
      format = "latex", booktabs = T)
```


:::
:::

## Normalidad univariada (cont.)

Considérese el análisis sobre las transformacions del ingreso laboral (miles $). Como se verificó en el **Módulo 2**, la transformación logarítmica reduce la influencia de los valores atípicos. En lo sucesivo, nuestro análisis emplea el **logaritmo del ingreso laboral**.

```{r, echo=F, eval = T, message=F, warning=F, prompt=FALSE, results = FALSE,fig.width= 6, fig.height=4}
library(car)

par(mfrow = c(2,2))
qqPlot(dataset$ingreso, ylab = "Ingreso laboral", main  = "Base")
qqPlot(log(dataset$ingreso), ylab = "Ingreso laboral", main = "Log transformation ")
qqPlot((dataset$ingreso)^(1/2), ylab = "Ingreso laboral", main = "Square root transformation ")
qqPlot((dataset$ingreso)^(1/3), ylab = "Ingreso laboral", main = "Cubic root transformation ")

```

## Resumen descriptivo (mediana e IQR)

Se verificó que las variables continuas no siguen una distribución normal y, en consecuencia, el resumen descriptivo reporta la mediana y el rango intercuartílico.

```{r, eval = T, echo=FALSE,message=F, warning=F}

quantile_f <- function(x){
  q1 <- quantile(x, na.rm = T, 0.25)
  q2 <- quantile(x, na.rm = T, 0.5)
  q3 <- quantile(x, na.rm = T, 0.75)
  y <- paste0(round(as.numeric(q2), 1), " (",
              round(as.numeric(q1), 2), " - ",
              round(as.numeric(q3), 2), ")")
  return(y)
}

total <- dataset %>% dplyr::select(ingreso,
                                    edad, horas_semana,
                                    t_actual, t_viaje) %>% 
  dplyr::summarise(across(everything(),
                   ~ quantile_f(.x)))

q_total <- data.frame(area = "Total",
                      ingreso_sum = total$ingreso,
                      edad_sum = total$edad,
                      horas_semana_sum = total$horas_semana,
                      t_actual_sum = total$t_actual,
                      t_viaje_sum = total$t_viaje)

# Resumen descriptivo por grupos
q_group <- dataset %>%
  dplyr::group_by(area) %>%
  dplyr::summarise(across(c("ingreso",
                     "edad", "horas_semana",
                     "t_actual", "t_viaje"),
                   list(sum = quantile_f))) %>% as.data.frame() 


cont_summary <- rbind(q_total, q_group)

kable(cont_summary, format = "latex",
                  booktabs = T, col.names = c("Área" ,"Ingreso",
                                              "Edad", "Horas (semana)", "Tiempo actual", "Tiempo de viaje"))
```

# Introducción al EDA multivariante

## EDA multivariante 

El **EDA multivariante** está fundamentado en la exploración, de manera simultánea, de dos o más características (variables) medidas en un conjunto de casos (Kachigan, 1991). El análisis univariante se centra en la variación, mientras que el análisis multivariante se centra en la **covariación** y **correlaciones** que refleja un conjunto de variables.

El análisis multivariante no sólo incluye estrategias de análisis exploratorio; sino, además, las siguientes técnicas:

- Componentes principales
- Análisis factorial
- Regresión múltiple
- Análisis discriminante múltiple
- Análisis multivariante de varianza
- Análisis cluster
- Análisis de correspondencias
- etc.


## Independencia de variables catégoricas

La siguiente gráfica representa la asociación entre el nivel educativo máximo alcanzado por el trabajador (**educación**) y el área metropolitana en que reside. 

```{r, echo = F, eval = T, fig.width= 7, fig.height=4}
ggplot(dataset,
       aes(x = factor(edu),
           fill = factor(edu))) + 

  geom_bar(
    aes(y = after_stat(count / ave(count, PANEL, FUN = sum)*100)),
    position = "dodge"
  ) + 

  labs(x = "Nivel de educación máxima", y = "Proporción (%)") + 
  
  ggtitle("Nivel de educación según área metropolitana") + 

  theme_bw() + 
  
  theme(plot.title = element_text(hjust = 0.5),
        axis.text.x = element_blank(),
        axis.ticks = element_blank()) +
  facet_wrap(~area, ncol = 5) +  labs(fill = "Nivel")

```


## Tabla de contingencia

La **tabla de contingencia** permite resumir la información reportada en la figura anterior:


```{r, echo = F, eval = T}
con1 <- table(dataset$area,dataset$edu)
con2 <- addmargins(con1)

kable(con2, format = "latex",
                  booktabs = T)
```


La conclusión es verificada mediante la implementación de una prueba $\chi^{2}$ de independencia

::: columns
::: {.column width="50%"}

AQUÍ VA LA DESCRIPCIÓN FORMAL DE LA PRUEBA CHI-2 DE INDEPENDENCIA
  
:::
  
::: {.column width="50%"}

```{r, echo = F, eval = T, warning=FALSE}
chisq.test(dataset$area, dataset$edu)
```

:::
:::


## Tabla de contingencia (cont.)

```{r, echo = F, eval = T}
mosaicplot(con1, las = 2, shade = T)
```


## Resumen: independencia de variables categóricas

```{r, echo = F, eval = T}
mosaicplot(con1, las = 2, shade = T)
```


## Resumen: independencia de variables categóricas

La siguiente es una forma útil de incluir la prueba $\chi^{2}$ de independencia en la visualización de los datos:

```{r, echo = F, eval = T}
library(ggpubr)

dataset$medio = fct_lump_n(factor(dataset$medio), 5)

edu_fondo <- dataset %>% dplyr::count(sexo, medio) %>%
  group_by(sexo) %>% mutate(perc = (n/sum(n))*100)

p.value <- chisq.test(dataset$sexo, dataset$medio)$p.value

f1 <- ggplot(edu_fondo, aes(x = sexo, y = perc,
                  fill = fct_reorder(medio, perc)) ) +
  geom_bar(stat = "identity", position = "dodge") + 
  annotate("text", x=1, y=13, label=paste0("Chi-2 test, p-value: ", signif(p.value,4))) +
  theme_bw() + scale_fill_brewer(palette = "PuOr") +
  labs(x = "Sexo", y = "Participación (%)",
       fill = "Medio")

p.value <- chisq.test(dataset$sexo, dataset$posic)$p.value

sp <- dataset %>% dplyr::count(sexo, posic) %>%
  group_by(sexo) %>% mutate(perc = (n/sum(n))*100)

f2 <- ggplot(sp, aes(x = sexo, y = perc,
                      fill = fct_reorder(posic, perc)) ) +
  geom_bar(stat = "identity", position = "dodge") + 
  annotate("text", x=1, y=28, label=paste0("Chi-2 test, p-value: ", signif(p.value,4))) +
  theme_bw() + scale_fill_brewer(palette = "PuOr") +
  labs(x = "Sexo", y = "Participación (%)",
       fill = "Puesto laboral")

ggarrange(f1, f2, ncol = 2)

```


